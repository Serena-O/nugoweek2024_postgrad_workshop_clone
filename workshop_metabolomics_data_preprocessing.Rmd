---
title: 'NuGOweek postgraduate course: introduction to metabolomics data preprocessing
  in R'
author: "Pablo Vangeenderhuysen, Matthijs Vynck, Michiel Adriaens"
date: '`r Sys.Date()`'
output: 
  html_document:
    fig_caption: true
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

## Preliminary info

This course will give a basic introduction on (untargeted) preprocessing of LC-MS (also extendable to GC-MS or LC-MS/MS) based metabolomics. 
The methods and workflow presented in this course our mainly based on the workflow presented by the [xcms package](https://bioconductor.org/packages/release/bioc/html/xcms.html) on Bioconductor. 

For this course, you will need R version > 4.4.

If you haven't already, the packages needed to complete today's course can be installed by running the next code block:

```{r eval=FALSE, include=TRUE}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("xcms")
BiocManager::install("MsExperiment")
BiocManager::install("Spectra")

```

And load the required packages:

```{r include=FALSE}
library(xcms)
library(MsExperiment)
library(Spectra)
```

## Review of LC-MS data

First, let's do a quick review of what kind of data we are dealing with.
LC-MS data is generated by first separating chemical molecules based on certain properties (e.g. polarity). Afterwards the molecules are ionized and in the MS instrument, they are separated based on their mass-to-charge ratio or *m/z* and their intensity (abundance) is measured. Thus, molecules are separated in two different dimensions, the retention time dimension (from the LC) and the mass-to-charge dimension (from the MS) making it easier to measure and identify molecules in more complex samples.



![Animation by Johannes Rainer & Phillipine Louail https://jorainer.github.io/xcmsTutorials/](assets/LC-MS-drawing.gif)


The workflow presented by xcms (but also applicable in for example MZmine3 and most untargeted algorithms) is:

* chromatographic peak detection: process in which chromatographic peaks are identified within a sample (file).
* alignment: process that adjusts for retention time differences (i.e. possible signal drifts from the LC) between measurements/samples.
* correspondence: grouping of chromatographic peaks (presumably from the same ion) across samples/files into LC-MS features


## Goals of the workshop

* Learn how to preprocess LC-MS data from open-source formats (such as .mzML) in R using xcms and other open-source packages
* Evaluate and understand the results of the preprocessing workflow
* Be able to build analysis workflows specifically tailored to your data


# Example dataset

In this course we are using a subset of the data presented in [Lloyd-Price et al. (2019)](https://www.nature.com/articles/s41586-019-1237-9). The subset is available to download via Metaboanalyst (https://new.metaboanalyst.ca/MetaboAnalyst/upload/SpectraUpload.xhtml) and contains 10 spectra (UPLC-Q/E-ESI-, C18) organized into three groups (Healthy, Crohn's Disease and QC). The data is already available in the open-source .mzML format.

# Importing LC-MS data

```{r warning=FALSE}
# Read the file names from the data folder
files <- list.files("data/",full.names = TRUE,pattern = ".mzML")

# Import the available metdata with the groups
metadata <- read.table("data/trimmed_metadata.txt",header = TRUE)
# Re-order metadata to match the files sequence
metadata <- metadata[order(metadata$Sample),]


#' Import the data of the experiment
ms_data <- readMsExperiment(files, sampleData = metadata)
```

Our object contains 4461 MS1 spectra in 10 samples

```{r}
ms_data
```

Various functions can be used to access specific data from the object:

```{r}
sampleData(ms_data)
```

```{r}
spectra(ms_data)
```


## Centroiding data

MS instruments allow to export data in profile or centroid mode. Profile data contains the signal for all discrete m/z values (and retention times) for which the instrument collected data (see first figure below). MS instruments continuously sample and record signals, therefore a mass peak for a single ion in one spectrum will consist of multiple intensities at discrete m/z values. The process to reduce this distribution of signals to a single representative mass peak (the centroid, see second figure below) is called centroiding. 

![Profile data](assets/serine-profile-mode-data-1.png)


![Centroid data](assets/centroiding-1.png)


In this case, we need to inspect if the data we are analyzing is profile data (and thus still needs to be centroided for use with xcms) or not. Usually, centroiding is performed when converting the data from the proprietary data fromat to .mzML, but it can also be performed in R (see https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html#centroiding-of-profile-ms-data).


We can easily check if the data is centroided using the function `isCentroided`. Checking in one file should be sufficient.

```{r}
isCentroided(spectra(ms_data[1]))

```
The function returns TRUE for all spectra in the sample.

Visually, we can check some of the centroided data for a known compound in the data (see suppplementary info of the Lloyd-Price paper).

|Method      |  mz| RT (min)| Metabolite|  
|:-----------------|----:|---:|----:|---:|
|C18n        | 538.3212|   8.66|  Met - Cholate| 




```{r}
#Here we extract the m/z and RT range for our compound in the two QC samples using filterRT & filterMzRange, afterwards we plot.
ms_data[c(9,10)] |>
    filterSpectra(filterMzRange,538.3212 + c(-0.005, 0.005)) |>
    filterSpectra(filterRt,519.6 + c(-10,10)) |>
    plot()
```



## Basic data inspection

We can inspect the total ion chromatogram using `chromatogram`. Setting aggregationFun = "sum" allows to calculate the total ion chromatogram (TIC), aggregationFun = "max" the base peak chromatogram (BPC).


```{r}
#' Extract and plot a BPC
tic <- chromatogram(ms_data, aggregationFun = "sum")
plot(tic,main = "Total Ion Chromatogram")
```
We can also create boxplots representing the distribution of the total ion currents per data file. Such plots can be very useful to spot potentially problematic MS runs.

```{r}
library(RColorBrewer)
## Generate a color set for the three groups
group_colors <- paste0(brewer.pal(3, "Set1")[1:3], "60")
names(group_colors) <- c("Control", "Disease","QC")

## Get the total ion current by file
tc <- spectra(ms_data) |>
    tic() |>
    split(f = fromFile(ms_data))
boxplot(tc, col = group_colors[sampleData(ms_data)$Disease],
        ylab = "intensity", main = "Total ion current")
```



# Data preprocessing

In this section, we will go through the 3 main steps of LC-MS preprocessing: peak picking, alignment and correspondence (and gap filling). Remember that you should tailor the parameters and settings to your specific dataset in you are refering to this document in the future.

## Chromatographic peak detection

Chromatographic peak detection aims to identify peaks along the retention time axis that represent the signal from individual compounds’ ions. This involves identifying and quantifying such signals as shown in the sketch below.

![Peak detection, sketch by J.Rainer & P. Louail](assets/LCMS-data-peaks.png)


Within xcms, several peak detection algorithms can be used and accessed by their respective parameter objects: `MatchedFilterParam`, `CentWaveParam` and `MassifquantParam`. However, in this workshop we will focus on the centWave algoritm (see the original publication (Tautenhahn, Böttcher, and Neumann 2008) for more details) as it is most frequently used in LC-MS metabolomics applications.

The different parameters available for the centWave algorithm can be called with `CentWaveParam`

```{r}
CentWaveParam()
```

It is strongly discouraged to use these default parameter settings for any of your preprocessing! There are tools available that automatically configure these parameters based on your data (such as IPO and autoTuner), but generally, the best results are obtained by tuning the parameters manually to your data and ions of interest. Before running any peak detection we can first visually inspect the extracted ion chromatogram of e.g. internal standards or compounds known to be present in the samples in order to evaluate and adapt the settings of the peak detection algorithm.


Let's take another look at our known compound that we inspected earlier:

```{r}
#define rt & mz ranges
rtr <- c(515, 530)
mzr <- 538.3212 + c(-0.005, 0.005)
## extract the chromatogram & add legend
chr_raw <- chromatogram(ms_data, mz = mzr, rt = rtr)
plot(chr_raw, col = group_colors[chr_raw$Disease],main = "Met - Cholate",xaxt ="n") 
legend(x = 525, y = 6e5, legend = c("Control","Disease","QC"),lty = 1,col =  group_colors,cex = 1)
axis(1, at = seq(515, 530, by = 1), las=2)

```


And let's try and run centWave peak detection with the default settings in this region:

```{r warning=FALSE}
#' Get default centWave parameters
cwp <- CentWaveParam()

#' "dry-run" peak detection on the EIC.
res <- findChromPeaks(chr_raw, param = cwp)
chromPeaks(res)
```


As expected, no peaks are found by the algorithm.

From the raw chromatogram, we can see that we have a 4 chromatographic peaks present in 2 of the control samples, and in 2 of the QC samples, but the peak seems to be absent in the disease samples. 


We can see that the peak width is quite small, at it's smallest it is about 5 seconds, so of course, running with a default minimum peakwidth of 20, yields no results.  In general, the lower and upper peak width should be set to include most of the expected chromatographic peak widths. A good rule of thumb is to set it from about half to about twice the average expected peak width. For the present data set we thus set peakwidth = c(2, 10).


Let's try again:

```{r warning=FALSE}
#'  centWave parameters
cwp <- CentWaveParam(peakwidth = c(2,10))

#' Peak detection on the EIC.
res <- findChromPeaks(chr_raw, param = cwp)
chromPeaks(res)
```


We still don't detect any peaks, so let's delve a little bit deeper into the parameters and find out what we can change to improve this.


From the help page we gather:

* snthresh	numeric(1) defining the signal to noise ratio cutoff.

When using centWave in extracted ion chromatograms, it has difficulty estimating the noise level, so it is advised to set this quite low (or even zero) and later use a higher value when performing peak detection in the complete data range.




Trying again:

```{r warning=FALSE}
#' centWave parameters
cwp <- CentWaveParam(peakwidth = c(2,10),snthresh = 2)

#' Peak detection on the EIC.
res <- findChromPeaks(chr_raw, param = cwp)
chromPeaks(res)
```


Now we do detect peaks in two of the samples, we can also plot the integration areas:


```{r}
plot(res)
```


This already looks promising, but a lot of the peaks we can see are still left out. Let's drop the sntresh to 1.

```{r warning=FALSE}
#' centWave parameters
cwp <- CentWaveParam(peakwidth = c(2,10),snthresh = 1)

#' Peak detection on the EIC.
res <- findChromPeaks(chr_raw, param = cwp)
chromPeaks(res)
```

```{r}
plot(res)
```


Now we already observe some strange behaviour! Notice that 4/5 peaks have a sn > 2 in our latest results, while in the first run with snthresh = 2, only two peaks were integrated. Indeed, the centWave algorithm can behave quite strange, especially in small rt & m/z ranges, so data evaluation afterwards is important. Also, we note that the small peak that is lying in the noise level in the plot, also get's integrated. 


```{r warning=FALSE}
#' centWave parameters
cwp <- CentWaveParam(peakwidth = c(2,10),snthresh = 1,noise = 8e4)

#' Peak detection on the EIC.
res <- findChromPeaks(chr_raw, param = cwp)
chromPeaks(res)
```

```{r}
plot(res)
```



Another important parameter to define for your data is ppm. 

* numeric(1) defining the maximal tolerated m/z deviation in consecutive scans in parts per million (ppm) for the initial ROI definition.


This is highly dependent on the instrument you are using and the precision you're expecting. In the next code block, we will check what the expected ppm deviation is for the ion.


To be a bit quicker, we will only check the QCs:

```{r}
target <- ms_data[c(9,10)] |>
    filterSpectra(filterMzRange,538.3212 + c(-0.005, 0.005)) |>
    filterSpectra(filterRt,519.6 + c(-10,10)) 
```


```{r}
plot(target)
```

We can observe some scattering of the data points around an m/z of 105.05 in the lower panel of the above plot. This scattering also decreases with increasing signal intensity (as for many MS instruments the precision of the signal increases with the intensity). To quantify the observed differences in m/z values for the signal of the ion we restrict the data to a  region with signal for the  ion. Below we first subset the data to the first file and then restrict the m/z range to values between 538.319 and 538.321

```{r}
#' Reduce the data set to signal of the ion
signal <- target[1] |>
    filterSpectra(filterMzRange,c(538.319, 538.321)) |>
    spectra()
```


We next extract the m/z values of the peaks from the consecutive scans and calculate the absolute difference between them.and express these differences in ppm (parts per million) of the average m/z of the peaks.

```{r}
#' Calculate the difference in m/z values between scans
mz_diff <- signal |>
    mz() |>
    unlist() |>
    diff() |>
    abs()

mz_diff * 1e6 / mean(unlist(mz(signal)))



```


It seems like the data is coming from a highly accurate instrument, as the ppm deviation is between 0 & 2! To accept some variance for other peaks that might me measured less accurately, we will set the ppm of centWave to 5.



It's recommended to perform the above step on a few known compounds and/or internal standard to get a good idea of what kind of parameters you should use for our dataset. Keeping our limited time in mind, we will try and see how we fare with our newly chosen parameters (leaving snthresh to the default of 10, to save some time and taking into account that centWave should better estimate the noise in the whole chromatogram).



```{r}
#' Perform peak detection on the full data set
cwp <- CentWaveParam(peakwidth = c(2, 10), ppm = 5,noise = 8e4,verboseBetaColumns = TRUE)
mse <- findChromPeaks(ms_data, param = cwp)
```


```{r}
mse
```

We detected 20311 peaks in the dataset!

Let's double check if we managed to integrate our known compound:


```{r}
chromPeaks(mse, mz = c(538.319, 538.321), rt = c(515, 535))
```

```{r}
eic <- chromatogram(mse,mz = c(538.319, 538.321), rt = c(515,530))
```
```{r}
plot(eic)
```





Note: sometimes peaks get wrongly split, for this, xcms has the function `refineChromPeaks()`, but we won't discuss this here. See the xcms documentation for more info.

## Retention time alignment

![Peak alignment, sketch by J.Rainer & P. Louail](assets/alignment.png)

## Correspondence

![Correspondence, sketch by J.Rainer & P. Louail](assets/correspondence2_03.png)

## Gap filling

# Data evaluation

# Conclusion and further analysis


